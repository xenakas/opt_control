---
output: 
  pdf_document:
    citation_package: natbib
    keep_tex: true
    fig_caption: true
    latex_engine: xelatex
title: " "
author: Антон
geometry: margin=1in
mainfont: Times New Roman
fontsize: 11pt
# spacing: double
header-includes:
 \usepackage[TS1,T2A]{fontenc}
 \usepackage[utf8]{inputenc}
 \usepackage[english,russian]{babel}
---


# Минимальное порождающее дерево

### 1. Постановка задачи

В городе М есть метро, состоящее из 16 станций, соединенных линиями. 
Предположим, что с изобретением нового вида транспорта метро стало нерентабельным, поэтому было решено закрыть часть линий, чтобы минимизировать издержки эксплуатации метро. 
Если считать, что затраты на обслуживание каждой линии линейно зависят от расстояния между станциями, а  вагоны мтеро ездят с постоянной скоростью, то можно считать, что затраты прямо пропорционально зависят от времени в пути между двумя станциями. 

Решим эту задачу на примере московского метрополитена. Выберем 16 станций и запишем время для перещения от одной станции к другой. (Источник: Яндекс.Метро - Схема метро Москвы  https://yandex.ru/metro/moscow )

```{r, eval=FALSE}


names <- c("Библиотека им. Ленина", "Охотный ряд", "Лубянка", "Чистые пруды", "Пушкинская", "Белорусская", "Китай-город", "Курская", "Таганская", "Третьяковская", "Трубная", "Менделеевская", "Проспект мира", "Комсомольская", "Краснопресненская", "Павелецкая")

for (i in 1:16){
cat("Станция №", i , ": ", names[i],  "\n\n" )
}


```


Станция № 1 :  Библиотека им. Ленина

Станция № 2 :  Охотный ряд

Станция № 3 :  Лубянка

Станция № 4 :  Чистые пруды

Станция № 5 :  Пушкинская

Станция № 6 :  Белорусская

Станция № 7 :  Китай-город

Станция № 8 :  Курская

Станция № 9 :  Таганская

Станция № 10 :  Третьяковская

Станция № 11 :  Трубная

Станция № 12 :  Менделеевская 

Станция № 13 :  Проспект мира

Станция № 14 :  Комсомольская

Станция № 15 :  Краснопресненская

Станция № 16 :  Павелецкая


\newpage



Построим взвешенный неориентрованный граф согласно полученным на Яндекс.Метро данных (вес указан в минутах):

```{r, echo = FALSE, out.width="90%"}
 library(knitr)
myimages<-list.files("/home/xenakas/Desktop/", pattern = ".png", full.names = TRUE)
include_graphics(myimages)

```


Составим матрицу весов ребер:



```{r, eval=FALSE}


newGraph<-function(n){                              #создание графа   
  G <- matrix(0,n,n) 
  return(G)  
} 


addEdge<-function(G,a1,a2, a3){                        #добавление дуги
  if((a1<=n)&(a2<=n)&(a1>0)&(a1>0)) { 
    G[a1,a2]<-a3 
    G[a2,a1]<-a3
  }else{
    print("Дуга не принадлежит графу") 
  }
  return(G)
} 



G<-newGraph(16)
n<-dim(G)[1]

G<-addEdge(G,1,2,2) 
G<-addEdge(G,1,5,7)
G<-addEdge(G,2,3,2)
G<-addEdge(G,2,5,7)
G<-addEdge(G,2,10,10)
G<-addEdge(G,3,4,2)
G<-addEdge(G,3,5,5)
G<-addEdge(G,3,7,5)
G<-addEdge(G,4,5,5)
G<-addEdge(G,4,8,9)
G<-addEdge(G,4,11,6)
G<-addEdge(G,4,13,10)
G<-addEdge(G,4,14,4)
G<-addEdge(G,5,6,4)
G<-addEdge(G,5,11,9)
G<-addEdge(G,5,15,6)
G<-addEdge(G,6,12,3)
G<-addEdge(G,6,15,3)
G<-addEdge(G,7,9,3)
G<-addEdge(G,7,10,5)
G<-addEdge(G,8,9,3)
G<-addEdge(G,8,14,9)
G<-addEdge(G,9,10,6)
G<-addEdge(G,9,16,3)
G<-addEdge(G,10,16,4)
G<-addEdge(G,11,12,6)
G<-addEdge(G,12,13,3)
G<-addEdge(G,13,14,9)

# 28 ребер

library(xtable)
xtable(G)


```



\begin{table}[h!]
\centering
\begin{tabular}{r|rrrrrrrrrrrrrrrr}

 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 \\ 
  \hline  
1 & $\infty$ & 2  &  $\infty$  &  $\infty$  & 7  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  \\ 
  2 & 2  &  $\infty$  & 2  &  $\infty$  & 7  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  10  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  \\ 
  3 &  $\infty$  & 2  &  $\infty$  & 2  & 5  &  $\infty$  & 5  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  \\ 
  4 &  $\infty$  &  $\infty$  & 2  &  $\infty$  & 5  &  $\infty$  &  $\infty$  & 9  &  $\infty$  &  $\infty$  & 6  &  $\infty$  &  10  & 4  &  $\infty$  &  $\infty$  \\ 
  5 & 7  & 7  & 5  & 5  &  $\infty$  & 4  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 9  &  $\infty$  &  $\infty$  &  $\infty$  & 6  &  $\infty$  \\ 
  6 &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 4  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 3  &  $\infty$  &  $\infty$  & 3  &  $\infty$  \\ 
  7 &  $\infty$  &  $\infty$  & 5  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 3  & 5  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  \\ 
  8 &  $\infty$  &  $\infty$  &  $\infty$  & 9  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 3  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 9  &  $\infty$  &  $\infty$  \\ 
  9 &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 3  & 3  &  $\infty$  & 6  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 3  \\ 
  10 &  $\infty$  &  10  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 5  &  $\infty$  & 6  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 4  \\ 
  11 &  $\infty$  &  $\infty$  &  $\infty$  & 6  & 9  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 6  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  \\ 
  12 &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 3  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 6  &  $\infty$  & 3  &  $\infty$  &  $\infty$  &  $\infty$  \\ 
  13 &  $\infty$  &  $\infty$  &  $\infty$  &  10  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 3  &  $\infty$  & 9  &  $\infty$  &  $\infty$  \\ 
  14 &  $\infty$  &  $\infty$  &  $\infty$  & 4  &  $\infty$  &  $\infty$  &  $\infty$  & 9  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 9  &  $\infty$  &  $\infty$  &  $\infty$  \\ 
  15 &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 6  & 3  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  \\ 
  16 &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  & 3  & 4  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  &  $\infty$  \\ 
   
\end{tabular}
\end{table}




```{r,eval=FALSE, echo=FALSE}
library(igraph)
g2 <- graph_from_adjacency_matrix(G, weighted=TRUE)

g1<-igraph::graph.adjacency(adjmatrix=G,mode="undirected", weighted = TRUE)
plot(g1, edge.label=round(E(g1)$weight, 3))

?graph.adjacency


```


\newpage


### 2. Пошаговое построение минимиального порождающего дерева
 
Пусть 
 $T = \varnothing,  V = \varnothing, U =  \{  1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16  \}$, 
где $V$ - множество пройденных вершин

```{r, eval=FALSE }
g_sort = G

mat_sort <- matrix(Inf,28,3)

text <- c()

k = 28

while ( sum(g_sort)  != 0 ) {
  
  max_el = which(g_sort == max(g_sort) , arr.ind = TRUE)
  
  
  mat_sort[k,1] <- max_el[dim(max_el)[1],1]
  mat_sort[k,2] <- max_el[dim(max_el)[1],2] 
  mat_sort[k,3] <- G[max_el[dim(max_el)[1],1], max_el[dim(max_el)[1],2]]
  
  vector<-c( "(" , max_el[dim(max_el)[1],1] , "," ,max_el[dim(max_el)[1],2] , "," ,  G[max_el[dim(max_el)[1],1], max_el[dim(max_el)[1],2]], "), " )
  text = c(vector, text)
  
  g_sort[max_el[dim(max_el)[1],1],max_el[dim(max_el)[1],2]] = 0
  k=k-1
  }
```


Создадим список ребер $R = \{(a_i, a_j, w_{ij}) \in G\}$,  отсортированный по возрастанию веса и по возрастанию номера вершины (где $a_i$ - начальная вершина ребра, $a_j$ - конечная вершина ребра, $w_{ij}$ - вес ребра,  $G_i$ - исходный граф):
\begin{multline*} 
R = \{ ( 1 , 2 , 2 ),  ( 2 , 3 , 2 ),  ( 3 , 4 , 2 ),  ( 7 , 9 , 3 ),  ( 8 , 9 , 3 ),  ( 6 , 12 , 3 ), ( 12 , 13 , 3 ),  ( 6 , 15 , 3 ),  
       ( 9 , 16 , 3 ),  \\ ( 5 , 6 , 4 ),  ( 4 , 14 , 4 ),  ( 10 , 16 , 4 ),  ( 3 , 5 , 5 ),  ( 4 , 5 , 5 ),  ( 3 , 7 , 5 ),  ( 7 , 10 , 5 ), 
       ( 9 , 10 , 6 ),  ( 4 , 11 , 6 ), ( 11 , 12 , 6 ), \\  ( 5 , 15 , 6 ),  ( 1 , 5 , 7 ),  ( 2 , 5 , 7 ),  ( 4 , 8 , 9 ),  ( 5 , 11 , 9 ),  
       ( 8 , 14 , 9 ),  ( 13 , 14 , 9 ),  ( 2 , 10 , 10 ),  ( 4 , 13 , 10 ) \} 
\end{multline*}

```{r, eval=FALSE, echo=FALSE}

sorted = mat_sort
T = c(sorted[1, ])                            # SpanningTree = {};
V = c(sorted[1,1], sorted[1,2]  )             # ReachSet = {0};                    # You can use any node...
U = seq(1,16)                                 # UnReachSet = {1, 2, ..., N-1};
U = U [! U %in% V]

T_text = c("(",      sorted[1,1], ", " ,  sorted[1,2], ", ",  sorted[1,3] , "), " )


sorted = sorted[-1, ]
k=1 

i=1

text = c()
V_text = c()
U_text = c()



while (sum(U) != 0 ) {                                        # while ( UnReachSet ≠ empty )
    if ((sorted[k,1]  %in%  V & sorted[k,2]  %in%  U) | (sorted[k,2]  %in%  V & sorted[k,1]  %in%  U)     ) {       #  x ∈ ReachSet   and  y  ∈ UnReachSet   and e has smallest cost
      
      T =   c(T, sorted[k, ])                       # SpanningTree = SpanningTree ∪ {e};
      
      if(sorted[k,1]  %in%  V & sorted[k,2]  %in%  U){
        V = c(V, sorted[k,2])                                              # ReachSet   = ReachSet ∪ {y};
        U = U [! U %in% V]                          #   UnReachSet = UnReachSet - {y};
        T_text = c(T_text,  "(",      sorted[k,1], ", " ,  sorted[k,2], ", ", sorted[k,3], "), " )
        
        }else{ 
          V = c(V, sorted[k,1])                                              # ReachSet   = ReachSet ∪ {y};
          U = U [! U %in% V]                          #   UnReachSet = UnReachSet - {y};
          T_text = c(T_text,  "(",      sorted[k,2], ", " ,  sorted[k,1], ", ", sorted[k,3], "), " )
          }
      
      i = i+1 
      
      for (j in 1:length(V))  {
        V_text = c(V_text, V[j], ", ") 
      }
      
      for (j in 1:length(U))  {
        U_text = c(U_text, U[j], ", ") 
      }
      
      
      text = c(text, "\n\n Шаг  ",  i,   "\n\n  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  \n\n  Минимальный элемент: $(",                 sorted[k,1], ", " ,  sorted[k,2], ", ", sorted[k,3], ")$  \n\n  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  \n\n  " ,                  "$V = пскобка" , V_text,    "лскобка$  \n\n     $U = пскобка", U_text,   "лскобка$   \n\n      Добавляем ребро в множество  $T$:  $T = пскобка ",  T_text, "лскобка$   \n\n  " ) 
      
      sorted = sorted[-k, ] 
      
      k = 1
      
      V_text = c()
      U_text = c()
      } else {
        k = k+1
      }
  }
  
print(T)

ttt = matrix(T, ncol = 3,  byrow = TRUE) 

sum(ttt[,3])  

sum(mat_sort[,3])  

cat(text)



```


Шаг 1

Находим в матрице ребро с минимальным весом   (если их несколько, выбираем в порядке возрастания вершин)

Минимальный элемент: $(1, 2, 2)$

Добавляем в множество пройденных вершин $V$ и удаляем из множества непройденных вершин $U$  начальную и конечную вершины этого ребра: $V = \{1, 2\}$, $U = \{3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 \}$

Добавляем ребро в множество  $T$:  $T = \{ (1, 2, 2) \}$ 







 Шаг   2 

  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  

  Минимальный элемент: $( 2 ,  3 ,  2 )$  

  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  

   $V = \{ 1 ,  2 ,  3   \}$  

  
  
   $U = \{ 4 ,  5 ,  6 ,  7 ,  8 ,  9 ,  10 ,  11 ,  12 ,  13 ,  14 ,  15 ,  16   \}$   

  Добавляем ребро в множество  $T$:  $T = \{  ( 1 ,  2 ,  2 ),  ( 2 ,  3 ,  2 )  \}$   


 Шаг   3 

  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  

  Минимальный элемент: $( 3 ,  4 ,  2 )$  

  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  

   $V = \{ 1 ,  2 ,  3 ,  4   \}$  

 $U = \{ 5 ,  6 ,  7 ,  8 ,  9 ,  10 ,  11 ,  12 ,  13 ,  14 ,  15 ,  16   \}$   

  Добавляем ребро в множество  $T$:  $T = \{  ( 1 ,  2 ,  2 ),  ( 2 ,  3 ,  2 ),  ( 3 ,  4 ,  2 )  \}$   

   \newpage

 Шаг   4 

  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  

  Минимальный элемент: $( 4 ,  14 ,  4 )$  

  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  

   $V = \{ 1 ,  2 ,  3 ,  4 ,  14   \}$  

   $U = \{ 5 ,  6 ,  7 ,  8 ,  9 ,  10 ,  11 ,  12 ,  13 ,  15 ,  16   \}$   

  Добавляем ребро в множество  $T$:  $T = \{  ( 1 ,  2 ,  2 ),  ( 2 ,  3 ,  2 ),  ( 3 ,  4 ,  2 ),  ( 4 ,  14 ,  4 )  \}$   

   

 Шаг   5 

  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  

  Минимальный элемент: $( 3 ,  5 ,  5 )$  

  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  

   $V = \{ 1 ,  2 ,  3 ,  4 ,  14 ,  5   \}$  

 $U = \{ 6 ,  7 ,  8 ,  9 ,  10 ,  11 ,  12 ,  13 ,  15 ,  16   \}$   

  Добавляем ребро в множество  $T$:  $T = \{  ( 1 ,  2 ,  2 ),  ( 2 ,  3 ,  2 ),  ( 3 ,  4 ,  2 ),  ( 4 ,  14 ,  4 ),  ( 3 ,  5 ,  5 )  \}$   

   

 Шаг   6 

  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  

  Минимальный элемент: $( 5 ,  6 ,  4 )$  

  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  

   $V = \{ 1 ,  2 ,  3 ,  4 ,  14 ,  5 ,  6   \}$  

   $U = \{ 7 ,  8 ,  9 ,  10 ,  11 ,  12 ,  13 ,  15 ,  16   \}$   

  Добавляем ребро в множество  $T$:  $T = \{  ( 1 ,  2 ,  2 ),  ( 2 ,  3 ,  2 ),  ( 3 ,  4 ,  2 ),  ( 4 ,  14 ,  4 ),  ( 3 ,  5 ,  5 ),  ( 5 ,  6 ,  4 )  \}$   

   

 Шаг   7 

  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  

  Минимальный элемент: $( 6 ,  12 ,  3 )$  

  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  

   $V = \{ 1 ,  2 ,  3 ,  4 ,  14 ,  5 ,  6 ,  12   \}$  

  $U =    \{ 7 ,  8 ,  9 ,  10 ,  11 ,  13 ,  15 ,  16   \}$   

Добавляем ребро в множество  $T$:  $T = \{  ( 1 ,  2 ,  2 ),  ( 2 ,  3 ,  2 ),  ( 3 ,  4 ,  2 ),  ( 4 ,  14 ,  4 ),  ( 3 ,  5 ,  5 ),  ( 5 ,  6 ,  4 ),  ( 6 ,  12 ,  3 )  \}$   

   \newpage

 Шаг   8 

  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  

  Минимальный элемент: $( 12 ,  13 ,  3 )$  

  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  

   $V = \{ 1 ,  2 ,  3 ,  4 ,  14 ,  5 ,  6 ,  12 ,  13   \}$  

  $U = \{7 ,  8 ,  9 ,  10 ,  11 ,  15 ,  16   \}$   

Добавляем ребро в множество  $T$:  $T = \{  ( 1 ,  2 ,  2 ),  ( 2 ,  3 ,  2 ),  ( 3 ,  4 ,  2 ),  ( 4 ,  14 ,  4 ),  ( 3 ,  5 ,  5 ),  ( 5 ,  6 ,  4 ),  ( 6 ,  12 ,  3 ),  ( 12 ,  13 ,  3 )  \}$   

   

 Шаг   9 

  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  

  Минимальный элемент: $( 6 ,  15 ,  3 )$  

  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  

   $V = \{ 1 ,  2 ,  3 ,  4 ,  14 ,  5 ,  6 ,  12 ,  13 ,  15   \}$  

  $U = \{7 ,  8 ,  9 ,  10 ,  11 ,  16   \}$   

Добавляем ребро в множество  $T$:  

$T = \{  ( 1 ,  2 ,  2 ),  ( 2 ,  3 ,  2 ),  ( 3 ,  4 ,  2 ),  ( 4 ,  14 ,  4 ),  ( 3 ,  5 ,  5 ),  ( 5 ,  6 ,  4 ),  ( 6 ,  12 ,  3 ),  ( 12 ,  13 ,  3 ),  ( 6 ,  15 ,  3 )  \}$   

   

 Шаг   10 

  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  

  Минимальный элемент: $( 3 ,  7 ,  5 )$  

  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  

   $V = \{ 1 ,  2 ,  3 ,  4 ,  14 ,  5 ,  6 ,  12 ,  13 ,  15 ,  7   \}$  

  $U = \{8 ,  9 ,  10 ,  11 ,  16   \}$   

Добавляем ребро в множество  $T$:  

$T = \{  ( 1 ,  2 ,  2 ),  ( 2 ,  3 ,  2 ),  ( 3 ,  4 ,  2 ),  ( 4 ,  14 ,  4 ),  ( 3 ,  5 ,  5 ),  ( 5 ,  6 ,  4 ),  ( 6 ,  12 ,  3 ),  ( 12 ,  13 ,  3 ),  ( 6 ,  15 ,  3 ),  ( 3 ,  7 ,  5 )  \}$   

   
\newpage

 Шаг   11 

  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  

  Минимальный элемент: $( 7 ,  9 ,  3 )$  

  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  

   $V = \{ 1 ,  2 ,  3 ,  4 ,  14 ,  5 ,  6 ,  12 ,  13 ,  15 ,  7 ,  9   \}$  

  $U = \{8 ,  10 ,  11 ,  16   \}$   

Добавляем ребро в множество  $T$:  

$T = \{  ( 1 ,  2 ,  2 ),  ( 2 ,  3 ,  2 ),  ( 3 ,  4 ,  2 ),  ( 4 ,  14 ,  4 ),  ( 3 ,  5 ,  5 ),  ( 5 ,  6 ,  4 ),  ( 6 ,  12 ,  3 ),  ( 12 ,  13 ,  3 ),  ( 6 ,  15 ,  3 ),  ( 3 ,  7 ,  5 ),  ( 7 ,  9 ,  3 )  \}$   

   

 Шаг   12 

  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  

  Минимальный элемент: $( 9 ,  16 ,  3 )$  

  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  

   $V = \{ 1 ,  2 ,  3 ,  4 ,  14 ,  5 ,  6 ,  12 ,  13 ,  15 ,  7 ,  9 ,  16   \}$  

  $U = \{8 ,  10 ,  11   \}$   

Добавляем ребро в множество  $T$:  
\begin{multline*}  
  T = \{  ( 1 ,  2 ,  2 ),  ( 2 ,  3 ,  2 ),  ( 3 ,  4 ,  2 ),  ( 4 ,  14 ,  4 ),  ( 3 ,  5 ,  5 ),  ( 5 ,  6 ,  4 ), \\  ( 6 ,  12 ,  3 ),  ( 12 ,  13 ,  3 ),  ( 6 ,  15 ,  3 ),  ( 3 ,  7 ,  5 ),  ( 7 ,  9 ,  3 ),  ( 9 ,  16 ,  3 )  \}
\end{multline*}   

   

 Шаг   13 

  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  

  Минимальный элемент: $( 7 ,  10 ,  5 )$  

  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  

   $V = \{ 1 ,  2 ,  3 ,  4 ,  14 ,  5 ,  6 ,  12 ,  13 ,  15 ,  7 ,  9 ,  16 ,  10   \}$  

  $U = \{8 ,  11   \}$   

Добавляем ребро в множество  $T$: 
\begin{multline*} 
T = \{  ( 1 ,  2 ,  2 ),  ( 2 ,  3 ,  2 ),  ( 3 ,  4 ,  2 ),  ( 4 ,  14 ,  4 ),  ( 3 ,  5 ,  5 ),  ( 5 ,  6 ,  4 ),  \\( 6 ,  12 ,  3 ),  ( 12 ,  13 ,  3 ),  ( 6 ,  15 ,  3 ),  ( 3 ,  7 ,  5 ),  ( 7 ,  9 ,  3 ),  ( 9 ,  16 ,  3 ),  ( 7 ,  10 ,  5 )  \}
\end{multline*}

   

 Шаг   14 

  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  

  Минимальный элемент: $( 4 ,  11 ,  6 )$  

  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  

   $V = \{ 1 ,  2 ,  3 ,  4 ,  14 ,  5 ,  6 ,  12 ,  13 ,  15 ,  7 ,  9 ,  16 ,  10 ,  11   \}$  

  $U = \{8   \}$   

Добавляем ребро в множество  $T$:  
\begin{multline*} 
T = \{  ( 1 ,  2 ,  2 ),  ( 2 ,  3 ,  2 ),  ( 3 ,  4 ,  2 ),  ( 4 ,  14 ,  4 ),  ( 3 ,  5 ,  5 ),  ( 5 ,  6 ,  4 ),  \\ ( 6 ,  12 ,  3 ),  ( 12 ,  13 ,  3 ),  ( 6 ,  15 ,  3 ),  ( 3 ,  7 ,  5 ),  ( 7 ,  9 ,  3 ),  ( 9 ,  16 ,  3 ),  ( 7 ,  10 ,  5 ),  ( 4 ,  11 ,  6 )  \}
\end{multline*}   

   

 Шаг   15 

  Находим ребро с минимальным   весом, смежное  с ребрами  дерева $T$:  

  Минимальный элемент: $( 4 ,  8 ,  9 )$  

  Добавляем  конечную вершину ребра в множество пройденных вершин $V$ и удаляем ее из множества непройденных вершин $U$:  

   $V = \{ 1 ,  2 ,  3 ,  4 ,  14 ,  5 ,  6 ,  12 ,  13 ,  15 ,  7 ,  9 ,  16 ,  10 ,  11 ,  8   \}$  

  $U = \{NA ,    \}$   

Добавляем ребро в множество  $T$:  
\begin{multline*} 
T = \{  ( 1 ,  2 ,  2 ),  ( 2 ,  3 ,  2 ),  ( 3 ,  4 ,  2 ),  ( 4 ,  14 ,  4 ),  ( 3 ,  5 ,  5 ),  ( 5 ,  6 ,  4 ), \\ ( 6 ,  12 ,  3 ),  ( 12 ,  13 ,  3 ),  ( 6 ,  15 ,  3 ),  ( 3 ,  7 ,  5 ),  ( 7 ,  9 ,  3 ),  ( 9 ,  16 ,  3 ),  ( 7 ,  10 ,  5 ),  ( 4 ,  11 ,  6 ),  ( 4 ,  8 ,  9 )  \}
\end{multline*}

 
\newpage

### 3. Выводы

С помощью алгоритма Прима мы получили минимальное порождающее дерево веса 59:



```{r, echo = FALSE, out.width="90%"}
 library(knitr)
myimages<-list.files("/home/xenakas/Desktop/", pattern = ".png", full.names = TRUE)
include_graphics(myimages)

```


Изначально был задан  граф веса 150. Если вернуться к поставленной задаче, то при прочих равных, закрыв все линии, кроме тех, что принадлежат минимальному порождающему дереву, мы получим экономию на эксплуатации метро в городе М примерно в 2.54 раза.

